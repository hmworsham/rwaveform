pkgs <- c('dplyr',
'tidyverse',
'ggplot2',
'raster',
'data.table',
'devtools',
'plotly',
'rPeaks',
'rwaveform',
'rgdal',
'caTools',
'sf',
'parallel',
'itcSegment',
'rlist',
'plot3D') # Name the packages you want to use here
# Function to install new packages if they're not already installed
load.pkgs <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# Runs the function on the list of packages defined in pkgs
load.pkgs(pkgs)
################################
# Setup workspace
################################
# Name data directory
#datadir <- '/global/scratch/users/worsham/waveform_binary_split'
datadir <- '/Volumes/GoogleDrive/My Drive/Research/RMBL/RMBL-East River Watershed Forest Data/Data/LiDAR/waveform_lidar_chunks'
# Name directory where inventory plot shapefiles live
#shapedir <- '/global/scratch/users/worsham/EastRiver/Plot_Shapefiles/Polygons/'
shapedir <- '/Volumes/GoogleDrive/My Drive/Research/RMBL/RMBL-East River Watershed Forest Data/Data/Geospatial/Kueppers_EastRiver_Plot_Shapefiles_WGS84UTM13N/Polygons'
# Name flightpaths as filenames
flightpaths <- list.files(datadir, full.names = T)
#intersectscsv <- '~/eastriver/Watershed_Spatial_Dataset/LiDAR/Output/EastRiver_Plot_LiDAR_Intersections.csv'
intersectcsv <- '/Volumes/GoogleDrive/My Drive/Research/RMBL/Working_Files/Watershed_Spatial_Dataset/Output/EastRiver_Plot_LiDAR_Intersections.csv'
intersects <- read.csv(intersectcsv)
names(intersects) <- str_replace(names(intersects), '\\.', '-')
################################
# Ingest binary files for one flightpath
################################
# Define area of interest by plot ID
aoi <- 'SG-NES2'
# Select flightpaths that intersect the aoi
itx_true <- intersects[intersects[aoi] == T,1]
#aoi_fps <- file.path(datadir, itx_true)
aoi_fps <- flightpaths
wf_arrays = ingest(aoi_fps[42])
# clip waveform to one plot extent
#aoiext = rwaveform::aoiextent('SG-NES2', shapedir)
#xyz = rwaveform::clipwf(wf_arrays, aoiext, buff=20)
# Subset to a manageable set of waveforms for testing
out <- wf_arrays$out
re <- wf_arrays$re
geol <- wf_arrays$geol
outir <- wf_arrays$outir
sysir <- wf_arrays$sysir
out_sub <- out[]
re_sub <- re[]
geol_sub <- geol[]
sub_arrays = list('out'=out_sub, 're'=re_sub, 'geol'=geol_sub)
tic <- proc.time()
decon <- rwaveform::deconv.apply(
wf_arrays,
sub_arrays,
method='Gold',
rescale=F,
small_paras = list(c(30,2,1.2,30,2,2)),
large_paras = list(c(40,4,1.8,30,2,2)))
toc <- proc.time()
print(toc-tic)
decon <- rwaveform::deconv.apply(
wf_arrays,
sub_arrays,
method='Gold',
rescale=F,
small_paras = list(c(30,2,1.2,30,2,2)),
large_paras = list(c(40,4,1.8,30,2,2)))
detach("package:rwaveform", unload = TRUE)
library(rwaveform)
# Install and load typical libraries
pkgs <- c('dplyr',
'tidyverse',
'ggplot2',
'raster',
'data.table',
'devtools',
'plotly',
'rPeaks',
'rwaveform',
'rgdal',
'caTools',
'sf',
'parallel',
'itcSegment',
'rlist',
'plot3D') # Name the packages you want to use here
# Function to install new packages if they're not already installed
load.pkgs <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# Runs the function on the list of packages defined in pkgs
load.pkgs(pkgs)
document()
# Create repository directory from template
setwd('~/Repos/')
# Update package documentation
setwd('rwaveform')
document()
# Name data directory
#datadir <- '/global/scratch/users/worsham/waveform_binary_split'
datadir <- '/Volumes/GoogleDrive/My Drive/Research/RMBL/RMBL-East River Watershed Forest Data/Data/LiDAR/waveform_lidar_chunks'
decon <- rwaveform::deconv.apply(
wf_arrays,
sub_arrays,
method='Gold',
rescale=F,
small_paras = list(c(30,2,1.2,30,2,2)),
large_paras = list(c(40,4,1.8,30,2,2)))
library(rwaveform)
decon
# Check for NaNs and extreme values
deconvals <- subset(decon, select = -index)
decon <- data.table(t(apply(subset(decon, select = -index), 1, peakfix)))
np <- apply(decon, 1, npeaks, smooth=F, threshold=0)
# Restore original index values
decon$index <- re_sub$index
setindex(decon, index)
# waveform decomposition
decomp <- apply(decon[,1:500],
1,
rwaveform::decom.adaptive,
smooth=T,
peakfix=T,
thres=0.001,
width=3)
decomp
